@import "tailwindcss";

@plugin "@tailwindcss/forms";
@plugin "@tailwindcss/typography";
@plugin "@iconify/tailwind4";

@custom-variant dark (&:where(.dark, .dark *));

@custom-variant catppuccin-latte (&:where(.catppuccin-latte-theme, .catppuccin-latte-theme *));
@custom-variant catppuccin-mocha (&:where(.catppuccin-mocha-theme, .catppuccin-mocha-theme *));
@custom-variant dracula (&:where(.dracula-theme, .dracula-theme *));
@custom-variant kanagawa-dragon (&:where(.kanagawa-dragon-theme, .kanagawa-dragon-theme *));
@custom-variant kanagawa-lotus (&:where(.kanagawa-lotus-theme, .kanagawa-lotus-theme *));
@custom-variant kanagawa-wave (&:where(.kanagawa-wave-theme, .kanagawa-wave-theme *));
@custom-variant nord (&:where(.nord-theme, .nord-theme *));

@theme {
  --font-pixel: "Jersey 10", mono;
  --font-code: "Fira Code", mono;
}

@theme inline {
  --color-light: var(--color-zinc-50);
  --color-dark: var(--color-zinc-950);
}

@layer components {
  body {
    @apply
      min-h-screen
      bg-light
      text-dark
      dark:bg-dark
      dark:text-light
      font-code;
  }

  a, input, select, textarea, button {
    @apply
      outline-none /* outline behaves inconsistently across different browser engines */
      ring-inherit /* use ring instead, applied in the @variant focus definition below */
      ring-offset-0; /* checkbox and radio are given a #fff ring-offset by default; we remove that here */
 
    @variant focus {
      @apply ring-2;
    }
  }

  input, select, textarea, button {
    @apply
      bg-inherit
      border-inherit
      text-inherit;
  }

  input, textarea {
    @apply
      caret-inherit;
  }

  select {
    /* Blink (Chromium) allows for option to be styled but does not support inherit */
    > option {
      @apply bg-light dark:bg-dark;
    }

    /* Blink (Chromium) Alternative Solution */
    /*
      Preserved for a hint towards targeting specific browsers
      NOTE: I am not confident that targeting -webkit-appearance is the correct solution; check alternatives
    */
    /*
    @supports (-webkit-appearance: none) {
      option {
        @apply bg-light dark:bg-dark;
      }
    }
    */
  }

  .prose {
    h1, h2, h3, h4, h5, h6 {
      @apply font-pixel;
    }
  }
}

@layer utilities {
  .prose {
    :where(pre):not(:where([class~="not-prose"], [class~="not-prose"] *)) {
      /* Catppuccin Latte Base for light mode and Catppuccin Mocha Crust for dark */
      /* NOTE: Syntax highlighting is configured in ../../../nuxt.config.ts */
      @apply
        bg-[#eff1f5]
        dark:bg-[#11111b]

        catppuccin-latte:bg-[#eff1f5]
        catppuccin-mocha:bg-[#11111b]
        dracula:bg-[#282a36]
        kanagawa-dragon:bg-[#181616]
        kanagawa-lotus:bg-[#F2ECBC]
        kanagawa-wave:bg-[#1F1F28]
        nord:bg-[#2e3440];
    }
  }

  [href$=".pdf"] > span[data-icon]:first-child:empty {
    /* TODO: Consider cases of not first-child (what if we want it appended, not prepended?)
     *       I think it should be the case that any span with data-icon or special class is
     *       given this sort of a treatment. Indeed, whether it is inside of a link tag or
     *       not. Though in such case, we would not be able to automatically infer class,
     *       just perhaps whether or not the span should be mr-2 or ml-2... perhaps? Maybe
     *       not, as this then disrupts usages inside differently spaced elements. */
    @apply icon-[fa7-solid--file-pdf] mr-2;
  }

  .content-renderer h2 a[href^="#"] {
    @apply
      hover:text-pink-500
      
      before:content-["#"]
      
      before:inline-block
      before:mr-[.2em]
      
      before:md:absolute
      before:md:-ml-[.8em]
      
      before:text-zinc-300
      dark:before:text-zinc-700;
  }
}
